// 构建现代 Web 应用的时候,需要应用 打包工具 webpack/ rollup, 将应用打包成一个或多个 bundle
// 如果文件过大, 就会导致在网络环境差或者设备性能差的条件下, 较高的首屏渲染时间和首次交互时间
// 所有需要分包, 将与首次渲染以及首屏交互的代码放到一块, 其他的代码加载次序靠后, 以免阻塞主线程
//
// 分包和懒加载是一个概念吗?
// 在webpack中，分包和懒加载通常是结合使用的。通过动态导入（import()）可以实现懒加载，
// 而SplitChunksPlugin等工具则可以帮助开发者进行有效的分包，以便更好地组织和管理代码块。
// 这样，开发者可以创建更小的、按需加载的代码块，从而提高应用程序的整体性能



// 加载 bundle.js 会阻塞主线程吗(顺便解答一下 输入 url 后发生了什么 + 三次握手四次挥手)
// 不会阻塞, 因为网络请求由专门的线程进行处理
// 首先是查询主机的 ip 地址, 先查看浏览器的缓存 chrome://net-internals#dns 是否存在主机的 ip
// 没有缓存的话, 调用系统的 gethostByName 函数查询 ip
// 这个函数会先查询当前主机的 hosts 文件是否存在所查询的主机,
// 没有的话, 就去当前局域网的 DNS 服务器或者默认网关进行查询,(设计 ARP 查询)
// 拿到 DNS 服务器或者默认网关的地址后, 通过 53 端口发送 UDP 请求包, 如果本地 DNS 服务器没有查询到主机对应的 ip ,那么它会向高层去进行递归的查询
// 拿到主机的 ip 后,就可以进行网络通信了
// 首先是浏览器调用系统库函数 socket, 建立一个 TCP流套接字, 数据首先被送到传输层封装层 TCP segment,加入一些端口信息, 目标端口和源地址端口(http: 80. http: 443)
// 然后数据送到网络层, 封装成 IP packet, 加入一些 ip 地址信息, 包括目标主机的 ip 和本机的 ip
// 然后数据被送到链路层, 加入 frame 头部, 加入本机网卡 MAC 信息和网关的 MAC 地址(数据包被传回来的时候, 根据这个信息再转发给对应的主机, 路由器之间传输数据不看这个信息, 只看 ip, 看这个没用)
// 不同的设备之间, 传输的只是数据, 但是有着不同用途的数据的划分, 形成了网络的六层模型(正如电脑主机执行的只是代码, 取指解码执行, 但是操作的不同数据和不同形式构建了各种不一样的软件)
// 上面讲了单个数据包的发送过程
// 从宏观上来讲, 建立连接包括一个三次握手四次挥手的过程,
// 三次握手，四次挥手是为了建立可靠的连接所设计的机制，其中涉及的一个原则就是通信的双方做了什么，对方知道自己做了什么。也就是 SYN, SYN-ACK, ACK 机制
// 四次挥手就是 FIN, ACK， FIN, ACK，三次握手对SYN 包的ACK 和自己方的 SYN 包，可以同时发送，因为建立连接是立即引起的（TCP的实现自己决定的）
// 四次挥手对 FIN 包的 ACK 不能伴随自己方的 FIN 包是因为关闭输出的字节流不是 TCP 的实现自己决定的，除非应用反应特别快，否则在应用决定发送FIN 包的时候， ACK 已经发送出去了。
// 这些机制都是为了可靠的传输数据而设计的，如果缺了哪一环，数据就不能被称为可靠的传输了
// TLS 握手， 安全传输的协议
// 使用非对称加密来安全地交换对称密钥，然后使用交换的密钥进行对称加密来加密实际的数据传输。这种方式既利用了对称加密的速度优势，也解决了密钥分发的问题。
// 先看看服务器端 CA 证书是否可信，可信的话，利用证书包含的公钥进行加密用于生成对称密钥的额随机数
// 服务器端进行解密，利用随机数生成对称密钥
// 客户端和服务器都使用之前交换的随机数和协商的加密算法生成会话密钥，并用它来加密一个Finished消息，这个消息包含之前所有握手消息的哈希值，以验证握手过程没有被篡改
// 整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容
// http 请求， 请求方法，路径， 协议， 请求体
// 响应状态码，description
// 响应体
// 101 转换协议（websocket 有用到）
// 200 成功
// 300 信息类的 301 重定向， 304 not modified（浏览器从缓存读取内容），
// 400 客户端错误 401 unauthorized，403 forbidden（不允许访问特定的路径或者方法）， 404 not found（没有找到所需的资源）, 403 bad method,
// 500 服务端错误 502, bad gateway, 503 server not available, 501 internal server error
// HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS
// html, css 解析渲染绘制，运行JavaScript


// 三次握手是TCP（传输控制协议）层面的一个过程，用于在两个网络节点之间建立一个可靠的连接。这一过程不涉及上层应用，而是发生在网络协议栈的传输层。
// 在三次握手完成后，上层应用（如HTTP、FTP等）才能够开始传输数据。这个过程确保了数据的正确顺序和可靠性，为上层应用提供了一个稳定的数据传输环境。